#!/usr/bin/env bash
  #==============================================
  # Project: bbm v0.5
  # Author:  ConzZah / (c) 2026
  # Last Modification: 2/9/26 10:33â€¯AM
  #==============================================

help () {
echo -e "\n=== bottles-backup-manager by ConzZah ==="
echo -e "\nbbm is a simple backup manager for bottles.\n
USAGE: bbm [-v] \n\n[-i] [/path/to/backup_xyz.tar.gz] \n\n[-e] [bottle-to-export]\n\n[-fix] [bottle-to-fix]\n" ;}
[ -z "$1" ] || [ "$1" = "-h" ] && help && exit

# shellcheck disable=SC1091
# https://www.shellcheck.net/wiki/SC1091
# REASON: .bbmrc is completely optional.

init () { 
bottles=""
components_url="https://github.com/bottlesdevs/components"
### check if flatpak & bottles are installed:
! command -v flatpak >/dev/null && echo -e "\n--> pls install flatpak.\n" && exit 1
! flatpak list| grep -q "bottles" && echo -e "\n--> pls install bottles.\n" && exit 1

### check if fzf is installed
! command -v fzf >/dev/null && echo -e "\n--> pls install fzf.\n" && exit 1

### check for & source .bbmrc to load overrides
[ -f '.bbmrc' ] && source '.bbmrc'

### try to set default paths if no custom path was specified in .bbmrc
## should the path not exist, fetch it from bottles-cli:
[ -z "$bottles" ] && { bottles="/home/$USER/.var/app/com.usebottles.bottles/data/bottles" ;}
[ ! -d "$bottles" ] && bottles="$(flatpak run --command=bottles-cli com.usebottles.bottles info bottles-path| sed 's#/bottles##')" 
bottle_path="$bottles/bottles"; runner_path="$bottles/runners"; wd="$(pwd)"
}

check_bottle () {
### checks if a bottle with the same name already exists
echo -e "\n--> CHECKING BACKUP.."
## make sure that user imput is actually a .tar.gz archive:
gztest="$(echo "$bottle_fn"| rev| cut -d '.' -f 1,2| rev)"
[ "$gztest" != "tar.gz" ] && echo -e "--> ERROR: BACKUP DOESN'T SEEM TO BE A .tar.gz ARCHIVE.\n" && exit 1
## if bottle.yml doesn't exist within the archive, exit 
! tar -tvf "$bottle_fn"| grep -m1 -oq "bottle.yml" && \
echo -e "--> ERROR: BACKUP DOESN'T CONTAIN ESSENTIAL CONFIGURATION FILES, EXITING.\n" && exit 1
## get the actual name of the bottle:
bottle_name="$(basename "$bottle_fn"| sed -e 's#backup_##g' -e 's#.tar.gz##g')"
## add bottle_name to bottle_path:
bottle_path="$bottle_path/$bottle_name"
## if the bottle doesn't already exist, continue.
## otherwise, ask the user if they want to overwrite it
[ ! -d "$bottle_path" ] && import_bottle || \
echo -e "\n--> WARNING: A BOTTLE WITH THE SAME NAME EXISTS ALREADY.\n\nDO YOU WANT TO OVERWRITE IT? [y/n]"
read -r yn; case $yn in
y|Y) rm -fr "${bottle_path:?}" && import_bottle ;;
*) echo -e "\n--> OVERWRITE CANCELED\n" && exit 0 
esac
}

import_bottle () {
### extracts bottle backup and cd's to it
mkdir -p "$bottle_path"; echo -e "\n--> EXTRACTING: ${bottle_name^^}"
tar -zx"${v}"f "$bottle_fn" -C "${bottle_path//$bottle_name/}" || \
{ echo -e "\n--> EXTRACTION ERROR.\n"; exit 1 ;}
## checks if bottle directory exists, cd's into it 
[ -d "$bottle_path" ] && cd "$bottle_path" || exit 1
fix_bottle
}

fix_bottle () {
## should $x equal fix,
## run in standalone mode
[ "$x" = "fix" ] && {
get_local_bottles; ask4bottle
[ -n "$bottle_name" ] && bottle_path="$bottle_path/$bottle_name"
[ -d "$bottle_path" ] && cd "$bottle_path" || exit 1 ;}
check_runner; check_components; fix_paths; quit
}

check_runner () {
component="runners"
### checks if the required runner is present, else downloads it.
req_component="$(grep -m1 "Runner" "bottle.yml"| cut -d ' ' -f 2)"
[ -d "$bottles/$component/$req_component" ] && echo -e "\n--> REQUIRED ${component^^} INSTALLED." && return
[ ! -d "$bottles/$component/$req_component" ]  && {
## find out if the required runner is proton or wine based ($rt = runner type)
! curl -sL "$components_url/tree/main/runners/wine"| grep -q "$req_component.yml" && rt="proton" || rt="wine"
## get runner.yml and download runner
yml="$(curl -sL "$components_url/raw/main/$component/$rt/$req_component.yml"| tr -s ' ')"
dl_component; popd >/dev/null || exit 1
}
}

check_components () {
### checks if components are required / present.
components="dxvk latencyflex vkd3d nvapi"
for component in $components; do
grep -iq ".*$component: false" 'bottle.yml' && echo -e "\n--> ${component^^} NOT REQUIRED." && continue
grep -iq ".*$component: true" 'bottle.yml' && {
req_component="$(grep -i -m1 "${component}-" "bottle.yml"| cut -d ' ' -f 2)"
## ^ if the component is set to true in bottle.yml, check for presence of the required version.
[ -d "$bottles/$component/$req_component" ] && echo -e "\n--> REQUIRED ${component^^} INSTALLED." && continue
[ ! -d "$bottles/$component/$req_component" ]  && {
## get yml
yml="$(curl -sL "$components_url/raw/main/$component/$req_component.yml"| tr -s ' ')"
dl_component; popd >/dev/null || exit 1 ;} ;}
done
}

dl_component () {
### downloads & extracts components
pushd "$bottles/$component" >/dev/null || exit 1
url="$(grep -o "url.*" <<< "$yml"| cut -d ' ' -f 2)"
md5="$(grep -o "file_checksum.*" <<< "$yml"| cut -d ' ' -f 2)"
fn="$(grep -o "file_name.*" <<< "$yml"| cut -d ' ' -f 2)"
name="$(grep -o "Name.*" <<< "$yml"| cut -d ' ' -f 2)"
## check header for 404s, if we got none, download.
curl -sLI "$url"| head -n1 | grep -qv '404' && {
## download component
echo -e "\n--> DOWNLOADING: $req_component\n"
curl -#Lo "$fn" "$url" ;}
## compare md5s & delete the file if they don't match
command -v 'md5sum' >/dev/null && [ -f "$fn" ] && {
echo -e "\n--> CHECKING MD5.."
! diff <(md5sum "$fn"| cut -d ' ' -f 1) <(echo "$md5") >/dev/null && \
echo -e "\n--> ERROR: MD5's DON'T MATCH, ABORTING.\n" && rm -f "$fn" ;}
## extract component
[ -f "$fn" ] && { tar -x"${v}"f "$fn"
old_name="$(tar -tf "$fn"| head -n1| sed 's#/##g')"
## ^ get the name of the top dir in the archive.
## if $name and $old_name differ, rename.
[ "$old_name" != "$name" ] && mv "$old_name" "$name"
rm -f "$fn" "LICENSE" >/dev/null ;}
}

# shellcheck disable=SC1003
# https://www.shellcheck.net/wiki/SC1003
# REASON: we don't need to escape any single quotes.

fix_paths () {
### AFFECTED FILES: bottle.yml, user.reg, system.reg
## get the old paths & overwrite them with the actual ones
echo -e "\n--> FIXING PATHS.."
pushd "$bottle_path" >/dev/null || exit 1

## check for the old_paths in bottle.yml
for query in 'folder' 'path'; do
old_path="$(grep -m1 -o "$query.*$bottle_name" bottle.yml| cut -d ' ' -f 2-)"
[ -n "$old_path" ] && [ "$bottle_path" != "$old_path" ] && \
sed -i "s#$old_path#$bottle_path#g" 'bottle.yml'
old_path=""
done

## get the old_runner_path in system.reg (bs = backslash)
## ( NOTE: "some" formatting is required because of the double backslashes, LORD HELP US )
bs_runner_path="$(echo "Z:$runner_path"| sed 's#/#\\\\\\\\#g')"
bs_old_runner_path="$(grep -m1 -o 'Z:.*\\runners' system.reg| sed 's#\\\\#\\\\\\\\#g')"
old_runner_path="$(echo "$bs_old_runner_path"|  tr '\\' '/'| sed 's#Z:##g'| tr -s '/')"
## compare runner paths, if they don't match, replace em.
[ -n "$old_runner_path" ] && [ "$old_runner_path" != "$runner_path" ] && \
sed -i "s~$bs_old_runner_path~$bs_runner_path~g" system.reg user.reg
popd >/dev/null || exit 1
}

export_bottle () {
### exports bottles
get_local_bottles; ask4bottle
pushd "$bottle_path" >/dev/null || exit 1 
tar -cz"${v}"f "$wd/backup_${bottle_name}.tar.gz" "$bottle_name" && quit || exit 1
popd >/dev/null || exit 1
}

dl_bottle () {
### download bottle backups from archive.org, using my downloader iadl.sh
### gets list of available bottles, opens fzf to let the user choose, and finally downloads & imports the chosen bottle
[ -f 'iadl.sh' ] && rm -f 'iadl.sh'; curl -sLO 'https://github.com/ConzZah/iadl/raw/main/iadl.sh'
[ -f 'iadl.sh' ] && bottle_fn="$(bash iadl.sh -fn 'https://archive.org/download/bottles-collection')" && \
[ -f "$bottle_fn" ] && check_bottle || exit 1
}

## lists local bottles
get_local_bottles () { pushd "$bottle_path" >/dev/null || exit 1; local_bottles="$(echo *| tr ' ' '\n')"; popd >/dev/null || exit 1 ;}

ask4bottle () {  
## if $bottle_name is not set yet, ask the user which bottle they want
[ -z "$bottle_name" ] && bottle_name="$(echo "$local_bottles"| fzf)"
## check if the bottle name entered actually exists
bottle_name="$(grep -m1 -i "$bottle_name" <<< "$local_bottles")"
[ -z "$bottle_name" ] || [ ! -d "$bottle_path/$bottle_name" ] && \
echo -e "\n--> ERROR: BOTTLE NOT FOUND\n" && exit 1
## prompt the user for confirmation
echo -e "\n--> ${x^^}: $bottle_name ?\n"
read -rp "[y/n] " yn
case $yn in 
y|Y) echo -e "\n--> ${x^^}ING: ${bottle_name^^}, PLEASE WAIT.." ;;
*) echo -e "\n--> ${x^^} CANCELED.\n" && exit
esac
}

quit () { echo -e "\n--> BOTTLE ${x^^}ED, SEE YA :D\n"; exit 0 ;}

init ### LAUNCH ### LAUNCH ### LAUNCH ### LAUNCH ### LAUNCH ###

## process user input
## verbose
[ "$1" = "-v" ] && v="v" && shift

## import
[ "$1" = "-i" ] && { x="import"
[ -n "$2" ] && [ -f "$2" ] && bottle_fn="$2" && check_bottle
[ ! -f "$2" ] && echo -e "\n--> ERROR: INVALID PATH.\n" && exit 1 ;}

## export
[ "$1" = "-e" ] && { x="export"; [ -n "$2" ] && bottle_name="$2"; export_bottle ;}

## fix bottles (paths & dependencies)
[ "$1" = "-fix" ] && { x="fix"; [ -n "$2" ] && bottle_name="$2"; fix_bottle ;}

## access collection
[ "$1" = "-collection" ] && x="import" && dl_bottle

## end of options
[ -n "$1" ] && echo -e "\n--> ERROR: UNRECOGNIZED OPTION." && help && exit 1
